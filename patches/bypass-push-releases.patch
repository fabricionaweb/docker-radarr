bypass can skip preferred protocol for pushed releases (from autobrr)

--- a/src/NzbDrone.Core/DecisionEngine/DownloadDecisionMaker.cs
+++ b/src/NzbDrone.Core/DecisionEngine/DownloadDecisionMaker.cs
@@ -67,6 +67,23 @@
             }

             var reportNumber = 1;
+            var source = pushedRelease ? ReleaseSourceType.ReleasePush : ReleaseSourceType.Rss;
+
+            if (searchCriteria != null)
+            {
+                if (searchCriteria.InteractiveSearch)
+                {
+                    source = ReleaseSourceType.InteractiveSearch;
+                }
+                else if (searchCriteria.UserInvokedSearch)
+                {
+                    source = ReleaseSourceType.UserInvokedSearch;
+                }
+                else
+                {
+                    source = ReleaseSourceType.Search;
+                }
+            }

             foreach (var report in reports)
             {
@@ -82,6 +99,7 @@
                     {
                         var remoteMovie = _parsingService.Map(parsedMovieInfo, report.ImdbId.ToString(), report.TmdbId, searchCriteria);
                         remoteMovie.Release = report;
+                        remoteMovie.ReleaseSource = source;

                         if (remoteMovie.Movie == null)
                         {
@@ -118,7 +136,8 @@
                             {
                                 Release = report,
                                 ParsedMovieInfo = parsedMovieInfo,
-                                Languages = parsedMovieInfo.Languages
+                                Languages = parsedMovieInfo.Languages,
+                                ReleaseSource = source
                             };

                             decision = new DownloadDecision(remoteMovie, new Rejection("Unable to parse release"));
@@ -129,7 +148,11 @@
                 {
                     _logger.Error(e, "Couldn't process release.");

-                    var remoteMovie = new RemoteMovie { Release = report };
+                    var remoteMovie = new RemoteMovie
+                    {
+                        Release = report,
+                        ReleaseSource = source
+                    };
                     decision = new DownloadDecision(remoteMovie, new Rejection("Unexpected error processing release"));
                 }

@@ -137,24 +160,6 @@

                 if (decision != null)
                 {
-                    var source = pushedRelease ? ReleaseSourceType.ReleasePush : ReleaseSourceType.Rss;
-
-                    if (searchCriteria != null)
-                    {
-                        if (searchCriteria.InteractiveSearch)
-                        {
-                            source = ReleaseSourceType.InteractiveSearch;
-                        }
-                        else if (searchCriteria.UserInvokedSearch)
-                        {
-                            source = ReleaseSourceType.UserInvokedSearch;
-                        }
-                        else
-                        {
-                            source = ReleaseSourceType.Search;
-                        }
-                    }
-
                     decision.RemoteMovie.ReleaseSource = source;

                     if (decision.Rejections.Any())
--- a/src/NzbDrone.Core/DecisionEngine/Specifications/RssSync/DelaySpecification.cs
+++ b/src/NzbDrone.Core/DecisionEngine/Specifications/RssSync/DelaySpecification.cs
@@ -44,6 +44,7 @@
             var delayProfile = _delayProfileService.BestForTags(subject.Movie.Tags);
             var delay = delayProfile.GetProtocolDelay(subject.Release.DownloadProtocol);
             var isPreferredProtocol = subject.Release.DownloadProtocol == delayProfile.PreferredProtocol;
+            var isPushedRelease = subject.ReleaseSource == ReleaseSourceType.ReleasePush;

             if (delay == 0)
             {
@@ -82,7 +83,7 @@
                 var bestQualityInProfile = profile.LastAllowedQuality();
                 var isBestInProfile = comparer.Compare(subject.ParsedMovieInfo.Quality.Quality, bestQualityInProfile) >= 0;

-                if (isBestInProfile && isPreferredProtocol)
+                if (isBestInProfile && (isPreferredProtocol || isPushedRelease))
                 {
                     _logger.Debug("Quality is highest in profile for preferred protocol, will not delay.");
                     return Decision.Accept();
@@ -95,7 +96,7 @@
                 var score = subject.CustomFormatScore;
                 var minimum = delayProfile.MinimumCustomFormatScore;

-                if (score >= minimum && isPreferredProtocol)
+                if (score >= minimum && (isPreferredProtocol || isPushedRelease))
                 {
                     _logger.Debug("Custom format score ({0}) meets minimum ({1}) for preferred protocol, will not delay", score, minimum);
                     return Decision.Accept();
